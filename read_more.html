<html>
    <body>
        <header>
            <h1 class="logo">OPERATING SYSTEM PROJECT</h1>
            <nav>
              <ul class="nav-links">
                <li><a href="main.html" target="_blank">Home</a></li>
                <li><a href="algorithm1.html" target="_blank">Preemptive Priority</a></li>
                <li><a href="algorithm2.html" target="_blank">Peterson's Solution</a></li>
                <li><a href="algorithm3.html" target="_blank">FCFS</a></li>
                <li><a href="algorithm4.html" target="_blank">Optimal Page Replacement</a></li>
              </ul>
            </nav>
          </header>
        <link rel="stylesheet" type="text/css" href="read_more.css">
        <link rel="stylesheet" href="animation.css">
            <h1><u>Documentation</u></h1>
    
        </section>
    
    
    
        <section class="container_docs" >
            <h1>What is CPU Scheduling?</h1>
            <p>CPU Scheduling is a process of determining which process will own CPU for execution while another process is
                on hold. The main task of CPU scheduling is to make sure that whenever the CPU remains idle, the OS at least
                select one of the processes available in the ready queue for execution. The selection process will be
                carried out by the CPU scheduler. It selects one of the processes in memory that are ready for execution.
            </p>
        </section>
    
        <section class="container_docs" data-aos="zoom-in-up">
            <h1>Why CPU Scheduling?</h1>
            <p>A typical process involves both I/O time and CPU time. In a uni programming system like MS-DOS, time spent
                waiting for I/O is wasted and CPU is free during this time. In multi programming systems, one process can
                use CPU while another is waiting for I/O. This is possible only with process scheduling.<br><br>
                <strong>Objectives of Process Scheduling Algorithm</strong>
                <li>Max CPU utilization [Keep CPU as busy as possible]</li>
                <li>Fair allocation of CPU.</li>
                <li>Max throughput [Number of processes that complete their execution per time unit]</li>
                <li>Min turnaround time [Time taken by a process to finish execution]</li>
                <li>Min waiting time [Time a process waits in ready queue]</li>
                <li>Min response time [Time when a process produces first response]</li>
    
            </p>
        </section>
    
        <section class="container_docs special" data-aos="zoom-in-up">
            <h1>Important CPU scheduling Terminologies</h1>
            <!-- <p>A typical process involves both I/O time and CPU time. In a uni programming system like MS-DOS, time spent waiting for I/O is wasted and CPU is free during this time. In multi programming systems, one process can use CPU while another is waiting for I/O. This is possible only with process scheduling.<br><br> -->
            <li><strong>Burst Time/Execution Time:</strong> It is a time required by the process to complete execution. It
                is also called running time.</li>
            <li><strong>Arrival Time:</strong> when a process enters in a ready state</li>
            <li><strong>Finish Time:</strong> when process complete and exit from a system</li>
            <li><strong>Multiprogramming:</strong> A number of programs which can be present in memory at the same time.
            </li>
            <li><strong>Jobs:</strong> It is a type of program without any kind of user interaction.</li>
            <li><strong>User:</strong> It is a kind of program having user interaction.</li>
            <li><strong>Process:</strong> It is the reference that is used for both job and user.</li>
            <li><strong>CPU/IO burst cycle:</strong> Characterizes process execution, which alternates between CPU and I/O
                activity. CPU times are shorter than the time of I/O.</li>
    
            </p>
        </section>
        <section class="container_docs" data-aos="zoom-in-up">
            <h1>Types of CPU Scheduling</h1>
            <p>There is mainly two major types of CPU Scheduling which is listed below.There is sub-types of this algorithm also. we have discussed all algorithm in details below. </p>
            <li>Preemptive Algorithm</li>
            <li>Non Preemptive Algorithm</li>
            <br>
    
            <p><strong class="bold">Preemptive Scheduling</strong><br><br>
                In Preemptive Scheduling, the tasks are mostly assigned with their priorities. Sometimes it is important to
                run a task with a higher priority before another lower priority task, even if the lower priority task is
                still running. The lower priority task holds for some time and resumes when the higher priority task
                finishes its execution.<br><br>
                <br>
                <strong class="bold">Non-Preemptive Scheduling</strong><br><br>
                In this type of scheduling method, the CPU has been allocated to a specific process. The process that keeps
                the CPU busy will release the CPU either by switching context or terminating. It is the only method that can
                be used for various hardware platforms. That’s because it doesn’t need special hardware (for example, a
                timer) like preemptive scheduling.
            </p>
    
            
    
        </section>
</html>